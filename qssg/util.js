//@ sourceMappingURL=util.map
// Generated by CoffeeScript 1.6.1
var createTaskTracker, deepExtend, fs, funcQueues, invokeList, path, stableSort,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty;

fs = require('fs');

path = require('path');

funcQueues = require('./funcQueues');

(function() {
  var k, v, _results;
  _results = [];
  for (k in funcQueues) {
    v = funcQueues[k];
    _results.push(exports[k] = v);
  }
  return _results;
})();

fs = Object.create(fs);

fs.makeDirs = function(aPath, mode, callback) {
  var step;
  if (callback == null) {
    callback = function() {};
  }
  if (typeof mode === 'function') {
    callback = mode;
    mode = void 0;
  }
  step = function(aPath, next) {
    return fs.exists(aPath, function(exists) {
      if (exists) {
        return next(null, false);
      }
      return step(path.dirname(aPath), function() {
        return fs.mkdir(aPath, mode, function(err) {
          return next(err, true);
        });
      });
    });
  };
  return step(path.resolve(aPath), callback);
};

exports.fs = fs;

deepExtend = function() {
  var d, ea, hash, k, other, others, q, tgt, v, _i, _len, _ref;
  hash = arguments[0], others = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  q = [];
  for (_i = 0, _len = others.length; _i < _len; _i++) {
    ea = others[_i];
    q.push([hash, ea]);
  }
  while (q.length) {
    _ref = q.pop(), tgt = _ref[0], other = _ref[1];
    for (k in other) {
      v = other[k];
      d = tgt[k];
      if (d == null) {
        tgt[k] = v;
      } else if (d instanceof Array) {
        d.push.apply(d, v);
      } else if (typeof v === 'object') {
        q.push([d, v]);
      } else {
        tgt[k] = v;
      }
    }
  }
  return hash;
};

exports.deepExtend = deepExtend;

createTaskTracker = function() {
  var doneFns, self;
  self = funcQueues.closureQueue.apply(funcQueues, arguments);
  doneFns = invokeList();
  if (self.done != null) {
    doneFns.push(self.done);
  }
  self.done = doneFns;
  self.seed = function() {
    process.nextTick(self());
    return self;
  };
  self.add = function() {
    var args, task;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    task = self();
    if (typeof args[args.length - 1] === 'function') {
      task = task.wrap(args.pop());
    }
    if (args.length != null) {
      task.args = args;
    }
    return task;
  };
  self.defer = function(ms, callback) {
    var task;
    if (typeof ms === 'function') {
      callback = ms;
      ms = null;
    }
    task = self(callback);
    if (ms != null) {
      setTimeout(task, ms);
    } else {
      process.nextTick(task);
    }
    return task;
  };
  return self;
};

exports.createTaskTracker = createTaskTracker;

stableSort = function(list, options) {
  var e, i, keyFn, res, tgt, _i, _len;
  if (options == null) {
    options = {};
  }
  keyFn = options.key || function(e) {
    return e;
  };
  res = [].map.call(list, function(e, i) {
    var w;
    return ((w = keyFn(e)) != null) && [w, i, e] || [null, i, e];
  });
  res.sort(function(a, b) {
    if (a[0] > b[0]) {
      return 1;
    }
    if (a[0] < b[0]) {
      return -1;
    }
    return a[1] - b[1];
  });
  tgt = options.inplace ? list : res;
  tgt.length = res.length;
  for (i = _i = 0, _len = res.length; _i < _len; i = ++_i) {
    e = res[i];
    if (e === void 0) {
      delete tgt[i];
    } else {
      tgt[i] = e.pop();
    }
  }
  return tgt;
};

exports.stableSort = stableSort;

exports.invokeList = invokeList = (function() {
  var init, invokeEach, methods;
  methods = {
    bind: function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (_ref = this.invoke).bind.apply(_ref, args);
    },
    call: function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (_ref = this.invoke).call.apply(_ref, args);
    },
    apply: function(self, args) {
      return this.invoke.apply(self, args);
    }
  };
  init = function() {
    var args, desc, each, k, self, v, _i, _len;
    self = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    desc = {};
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      each = args[_i];
      for (k in each) {
        if (!__hasProp.call(each, k)) continue;
        v = each[k];
        desc[k] = {
          value: v
        };
      }
    }
    Object.defineProperties(self, desc);
    return self;
  };
  invokeEach = function(self, args, error) {
    var fn, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = self.length; _i < _len; _i++) {
      fn = self[_i];
      try {
        _results.push(fn.apply(null, args));
      } catch (err) {
        if (self.error != null) {
          _results.push(self.error(err));
        } else if (error != null) {
          _results.push(error(err));
        } else {
          _results.push(console.error(err.stack || err));
        }
      }
    }
    return _results;
  };
  invokeList = function(self, error) {
    if (self == null) {
      self = [];
    }
    return init(self, methods, {
      once: [],
      invoke: function() {
        invokeEach(self.once.splice(0), arguments, error);
        invokeEach(self, arguments, error);
        return this;
      }
    });
  };
  invokeList.dual = invokeList;
  invokeList.create = invokeList;
  invokeList.simple = function(self, error) {
    if (self == null) {
      self = [];
    }
    return init(self, methods, {
      invoke: function() {
        invokeEach(self, arguments, error);
        return this;
      }
    });
  };
  invokeList.once = function(self, error) {
    if (self == null) {
      self = [];
    }
    return init(self, methods, {
      invoke: function() {
        invokeEach(self.splice(0), arguments, error);
        return this;
      }
    });
  };
  invokeList.ordered = function(self, error) {
    if (self == null) {
      self = [];
    }
    return init(self, methods, {
      add: function(w, fn) {
        if (typeof w === 'function') {
          fn = w;
          w = arguments[1];
        }
        if (w !== void 0) {
          fn.w = w;
        }
        return self.push(fn);
      },
      sort: function() {
        return stableSort(self, {
          inplace: true,
          key: function(e) {
            return e.w || 0;
          }
        });
      },
      invoke: function() {
        invokeEach(self.sort(), arguments, error);
        return this;
      },
      iter: function(iterFn) {
        var q;
        q = self.sort().slice();
        return function() {
          var args, fn;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          while (q.length && fn === void 0) {
            fn = q.shift();
          }
          args.unshift(fn);
          return iterFn.apply(null, args);
        };
      }
    });
  };
  return invokeList;
})();

function debounce(wait, fn) {
  if (typeof wait === 'function')
    fn=wait, wait=arguments[1];
  var self, args, tid,
    dfn = function(){ fn.apply(self, args) }
  return function(){
    tid = clearTimeout(tid);
    self = this; args = arguments;
    tid = setTimeout(dfn, wait); } }
;

exports.debounce = debounce;
