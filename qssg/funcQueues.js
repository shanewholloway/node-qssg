// Generated by CoffeeScript 1.6.1
var closureQueue, taskQueue;

closureQueue = function(tgt, callback) {
  var finish, k, nComplete, nStarted, self, start, v;
  if (typeof tgt === 'function') {
    callback = tgt;
    tgt = null;
  }
  nStarted = 0;
  nComplete = 0;
  start = function(anserFn) {
    if (typeof self.start === "function") {
      self.start(self, nStarted - nComplete);
    }
    nStarted++;
    if (anserFn == null) {
      return finish;
    }
    return finish.wrap(anserFn);
  };
  finish = function() {
    var isdone, _ref;
    isdone = ++nComplete === nStarted;
    if (typeof self.finish === "function") {
      self.finish(self, nStarted - nComplete);
    }
    if (isdone) {
      if ((_ref = self.done) != null) {
        _ref.call(self, self, nComplete);
      }
      if (typeof callback === "function") {
        callback(null, self, nComplete);
      }
    }
    return isdone;
  };
  finish.wrap = function(anserFn) {
    if (anserFn == null) {
      return finish;
    }
    return function() {
      try {
        return anserFn.apply(this, arguments);
      } finally {
        finish();
      }
    };
  };
  Object.defineProperties(self = start, {
    started: {
      get: function() {
        return nStarted;
      }
    },
    completed: {
      get: function() {
        return nComplete;
      }
    },
    active: {
      get: function() {
        return nStarted - nComplete;
      }
    },
    inspect: {
      value: function() {
        return "[closureQueue active: " + this.active + " completed: " + this.completed + "]";
      }
    },
    toString: {
      value: function() {
        return this.inspect();
      }
    },
    isIdle: {
      value: function() {
        return nComplete === nStarted;
      }
    },
    isDone: {
      value: function() {
        return nComplete === nStarted && nStarted > 0;
      }
    }
  });
  if (tgt != null) {
    for (k in tgt) {
      v = tgt[k];
      self[k] = v;
    }
  }
  return self;
};

exports.closureQueue = closureQueue;

taskQueue = function(limit, tgt, callback) {
  var addTask, cq, doTask, extendTasks, invokeTask, k, self, step, taskq, v;
  if (typeof limit === 'function') {
    callback = limit;
    tgt = null;
    limit = 9e9;
  }
  if (typeof tgt === 'function') {
    callback = tgt;
    tgt = null;
  }
  if (!isFinite(limit)) {
    tgt = limit;
    limit = ((tgt != null ? tgt.limit : void 0) || 9e9) + 0;
  }
  cq = closureQueue({
    finish: function(cq, nActive) {
      self.step(-1);
    },
    done: function(cq, nComplete) {
      var _ref;
      if (typeof callback === "function") {
        callback(null, self, nComplete);
      }
      if ((_ref = self.done) != null) {
        _ref.call(self, self, nComplete);
      }
    }
  });
  taskq = [];
  addTask = function(fn) {
    taskq.push(fn);
    self.step(+1);
    return self;
  };
  doTask = function(fn) {
    return addTask(function(done) {
      try {
        return fn();
      } finally {
        done();
      }
    });
  };
  extendTasks = function(fnList) {
    taskq = taskq.concat(fnList);
    self.step(fnList.length);
    return self;
  };
  step = function() {
    while (taskq.length > 0 && limit >= cq.active) {
      if (self.invokeTask(taskq.shift(), cq)) {
        return self;
      }
    }
    return self;
  };
  invokeTask = function(task, cq) {
    try {
      if (typeof task === "function") {
        task(cq());
      }
    } catch (err) {
      if (self.error != null) {
        self.error(err);
      } else {
        console.error(err.stack || err);
      }
    }
  };
  Object.defineProperties(self = addTask, {
    active: {
      get: function() {
        return cq.active;
      }
    },
    backlog: {
      get: function() {
        return taskq.length;
      }
    },
    incomplete: {
      get: function() {
        return cq.active + taskq.length;
      }
    },
    completed: {
      get: function() {
        return cq.completed;
      }
    },
    inspect: {
      value: function() {
        return "[taskQueue backlog: " + this.backlog + " active: " + this.active + " completed: " + this.completed + "]";
      }
    },
    toString: {
      value: function() {
        return this.inspect();
      }
    },
    "do": {
      value: doTask
    },
    extend: {
      value: extendTasks
    },
    step: {
      value: step
    },
    invokeTask: {
      value: invokeTask
    },
    isIdle: {
      value: function() {
        return taskq.length === 0 && cq.isIdle();
      }
    },
    isDone: {
      value: function() {
        return taskq.length === 0 && cq.isDone();
      }
    }
  });
  if (tgt != null) {
    for (k in tgt) {
      v = tgt[k];
      self[k] = v;
    }
  }
  return self;
};

exports.taskQueue = taskQueue;
