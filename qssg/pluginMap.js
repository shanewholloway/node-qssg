// Generated by CoffeeScript 1.6.1
var PipelinePlugin, PluginBaseMap, PluginCompositeMap, PluginDirsMap, PluginFilesMap, exports,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

PipelinePlugin = require('./pluginTypes').PipelinePlugin;

PluginBaseMap = (function() {

  function PluginBaseMap() {
    Object.defineProperties(this, {
      db: {
        value: {}
      },
      _cache: {
        value: {}
      }
    });
  }

  PluginBaseMap.prototype.invalidate = function() {
    this._cache = {};
    return this;
  };

  PluginBaseMap.prototype.reset = function() {
    this.db = {};
    return this.invalidate();
  };

  PluginBaseMap.prototype.clone = function() {
    var self;
    self = Object.create(this, {
      db: {
        value: Object.create(this.db)
      }
    });
    return self.invalidate();
  };

  PluginBaseMap.prototype.freeze = function(deep) {
    var hash;
    if (deep == null) {
      deep = true;
    }
    this.exportPluginsTo(hash = {}, deep);
    return this.reset().merge(hash);
  };

  PluginBaseMap.prototype.exportPluginsTo = function(tgt, deep) {
    var key, pi, _ref, _ref1;
    if (deep) {
      _ref = this.db;
      for (key in _ref) {
        pi = _ref[key];
        tgt[key] = pi;
      }
    } else {
      _ref1 = this.db;
      for (key in _ref1) {
        if (!__hasProp.call(_ref1, key)) continue;
        pi = _ref1[key];
        tgt[key] = pi;
      }
    }
    return tgt;
  };

  PluginBaseMap.prototype.merge = function(plugins) {
    var hash;
    if (plugins === true) {
      return this.freeze();
    } else if (plugins === false) {
      return this.reset();
    } else {
      if (plugins.exportPluginsTo != null) {
        plugins.exportPluginsTo(hash = {});
      } else {
        hash = plugins;
      }
      this.addPluginHash(hash);
    }
    return this.invalidate();
  };

  PluginBaseMap.prototype.addPluginHash = function(hash, deep) {
    var key, pi;
    if (deep) {
      for (key in hash) {
        pi = hash[key];
        if (this.acceptPlugin(pi)) {
          this.db[key] = pi;
        }
      }
    } else {
      for (key in hash) {
        if (!__hasProp.call(hash, key)) continue;
        pi = hash[key];
        if (this.acceptPlugin(pi)) {
          this.db[key] = pi;
        }
      }
    }
    return this.invalidate();
  };

  PluginBaseMap.prototype.addPluginAt = function(keys, pi) {
    var k, _i, _len;
    if (this.acceptPlugin(pi)) {
      if (keys.split != null) {
        keys = [keys];
      }
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        k = keys[_i];
        this.db[k] = pi;
      }
      return this.invalidate();
    }
    return this;
  };

  PluginBaseMap.prototype.acceptPlugin = function(pi) {
    throw new Error("Subclass responsibility. (" + this.constructor.name + ")");
  };

  PluginBaseMap.prototype.findPluginForExt = function(ext, entry) {
    var pi;
    if ((pi = this._cache[ext]) == null) {
      this._cache[ext] = pi = this._findPluginForExt(ext, entry);
    }
    return pi;
  };

  PluginBaseMap.prototype._findPluginForExt = function(ext, entry) {
    throw new Error("Subclass responsibility. (" + this.constructor.name + ")");
  };

  PluginBaseMap.prototype.findPluginForKind = function(kind0, entry) {
    var pi_kind;
    if (kind0 != null) {
      pi_kind = this.db['&' + kind0];
      if ((pi_kind == null) && kind0.match(/\D/)) {
        console.warn("Plugin for kind '" + entry.kind0 + "' not found. (re: " + entry.srcRelPath + ")");
      }
    }
    return pi_kind || this.db['&'];
  };

  return PluginBaseMap;

})();

PluginFilesMap = (function(_super) {

  __extends(PluginFilesMap, _super);

  function PluginFilesMap() {
    return PluginFilesMap.__super__.constructor.apply(this, arguments);
  }

  PluginFilesMap.prototype.acceptPlugin = function(pi) {
    return pi.isFilePlugin;
  };

  PluginFilesMap.prototype._findPluginForExt = function(ext, entry) {
    var i, n, pi, pi_list;
    n = ext.length;
    if (n === 0) {
      return this.db[''];
    }
    pi = this.db[ext[n - 1]];
    if (n > 1) {
      pi_list = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = _ref = n - 2; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
          _results.push(this._lookupPair(ext[i], ext[i + 1]));
        }
        return _results;
      }).call(this);
      pi_list[0] || (pi_list[0] = pi);
      i = pi_list.indexOf(void 0);
      if (~i) {
        pi_list.splice(i);
      }
      if (pi_list.length > 1) {
        pi = this.asPluginPipeline(pi_list, ext);
      } else {
        pi = pi_list.pop();
      }
    }
    return pi || this["default"];
  };

  PluginFilesMap.prototype._lookupPair = function(fmt, ext) {
    return this.db[[fmt, ext]] || this.db[[fmt, '*']] || this.db[['*', ext]];
  };

  PluginFilesMap.prototype.asPluginPipeline = function(pluginList, ext) {
    return new PipelinePlugin(pluginList, ext);
  };

  return PluginFilesMap;

})(PluginBaseMap);

PluginDirsMap = (function(_super) {

  __extends(PluginDirsMap, _super);

  function PluginDirsMap() {
    return PluginDirsMap.__super__.constructor.apply(this, arguments);
  }

  PluginDirsMap.prototype.acceptPlugin = function(pi) {
    return pi.isDirPlugin;
  };

  PluginDirsMap.prototype._findPluginForExt = function(ext, entry) {
    if (ext.length === 0) {
      return this.db[''];
    }
    if (ext.length > 1) {
      console.warn("Multiple extensions on directories are undefined. (re: " + entry.srcRelPath + ")");
    }
    return this.db[ext[0]];
  };

  return PluginDirsMap;

})(PluginBaseMap);

PluginCompositeMap = (function() {

  function PluginCompositeMap() {}

  PluginCompositeMap.prototype.PluginDirsMap = PluginDirsMap;

  PluginCompositeMap.prototype.PluginFilesMap = PluginFilesMap;

  PluginCompositeMap.prototype._initPluginMaps = function() {
    this.dirsMap = new this.PluginDirsMap();
    this.filesMap = new this.PluginFilesMap();
    return this.reset();
  };

  PluginCompositeMap.prototype.invalidate = function() {
    this.dirsMap.invalidate();
    this.filesMap.invalidate();
    return this;
  };

  PluginCompositeMap.prototype.reset = function() {
    this.dirsMap.reset();
    this.filesMap.reset();
    return this;
  };

  PluginCompositeMap.prototype.clone = function() {
    var self;
    self = Object.create(this);
    self.dirsMap = this.dirsMap.clone();
    self.filesMap = this.filesMap.clone();
    return self;
  };

  PluginCompositeMap.prototype.freeze = function(deep) {
    this.dirsMap.freeze(deep);
    this.filesMap.freeze(deep);
    return this;
  };

  PluginCompositeMap.prototype.exportPluginsTo = function(tgt, deep) {
    this.dirsMap.freeze(tgt, deep);
    this.filesMap.freeze(tgt, deep);
    return tgt;
  };

  PluginCompositeMap.prototype.merge = function(plugins) {
    this.dirsMap.merge(plugins);
    this.filesMap.merge(plugins);
    return this;
  };

  PluginCompositeMap.prototype.addPluginHash = function(hash) {
    this.dirsMap.addPluginHash(hash);
    this.filesMap.addPluginHash(hash);
    return this;
  };

  PluginCompositeMap.prototype.addPluginAt = function(keys, pi) {
    this.dirsMap.addPluginAt(keys, pi);
    this.filesMap.addPluginAt(keys, pi);
    return this;
  };

  PluginCompositeMap.prototype.findPluginForExt = function(ext, entry, matchKind) {
    if (entry.isDirectory()) {
      return this.dirsMap.findPluginForExt(kind0, entry, matchKind);
    } else {
      return this.filesMap.findPluginForExt(kind0, entry, matchKind);
    }
  };

  PluginCompositeMap.prototype.findPluginForKind = function(kind0, entry, matchKind) {
    if (entry.isDirectory()) {
      return this.dirsMap.findPluginForKind(kind0, entry, matchKind);
    } else {
      return this.filesMap.findPluginForKind(kind0, entry, matchKind);
    }
  };

  return PluginCompositeMap;

})();

module.exports = exports = {
  PluginBaseMap: PluginBaseMap,
  PluginFilesMap: PluginFilesMap,
  PluginDirsMap: PluginDirsMap,
  PluginCompositeMap: PluginCompositeMap
};
