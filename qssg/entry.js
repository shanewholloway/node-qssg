// Generated by CoffeeScript 1.6.1
var MatchEntry, MatchingWalker, stream, tromp,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

stream = require('stream');

tromp = require('tromp');

MatchEntry = (function() {

  Object.defineProperties(MatchEntry.prototype, {
    srcName: {
      get: function() {
        return this.src.name;
      }
    },
    srcPath: {
      get: function() {
        return this.src.path;
      }
    },
    srcRelPath: {
      get: function() {
        return this.src.relPath;
      }
    },
    mode: {
      get: function() {
        return this.src.mode;
      }
    },
    stat: {
      get: function() {
        return this.src.stat;
      }
    },
    path: {
      get: function() {
        return this.src.node.resolve(this.name);
      }
    },
    relPath: {
      get: function() {
        return this.src.node.relative(this.path);
      }
    },
    rootPath: {
      get: function() {
        return this.src.node.rootPath;
      }
    },
    parentEntry: {
      get: function() {
        return this.src.node.entry;
      }
    },
    ctx: {
      get: function() {
        return this.contentItem.ctx;
      }
    },
    ctx_w: {
      get: function() {
        var _ref;
        return ((_ref = this.contentTree) != null ? _ref.ctx : void 0) || this.baseTree.ctx;
      }
    },
    name: {
      get: function() {
        var ext;
        ext = this.ext.join('.');
        return this.name0 + (ext && "." + ext || '');
      }
    }
  });

  MatchEntry.prototype.isFile = function() {
    return this.src.isFile();
  };

  MatchEntry.prototype.isDirectory = function() {
    return this.src.isDirectory();
  };

  function MatchEntry(walkEntry, baseTree, pluginMap) {
    var ext, name0;
    ext = walkEntry.name.split('.');
    name0 = ext.shift();
    Object.defineProperties(this, {
      src: {
        value: walkEntry
      },
      srcName0: {
        value: name0
      },
      srcExt: {
        get: function() {
          return ext.slice();
        }
      },
      stat: {
        value: walkEntry.stat
      },
      baseTree: {
        value: baseTree
      },
      pluginMap: {
        value: pluginMap
      }
    });
    this.name0 = name0;
    this.ext = ext.slice();
  }

  MatchEntry.prototype.setMatchMethod = function(matchKind) {
    if (this.baseTree.adaptMatchKind != null) {
      matchKind = this.baseTree.adaptMatchKind(matchKind, entry);
    }
    if (this.isDirectory()) {
      return this.matchMethod = matchKind + 'Dir';
    } else {
      return this.matchMethod = matchKind;
    }
  };

  MatchEntry.prototype.toJSON = function() {
    return {
      path: this.relPath,
      src: {
        path: this.relPath,
        mode: this.mode
      }
    };
  };

  MatchEntry.prototype.inspect = function() {
    return "[" + this.constructor.name + " " + this.mode + ":'" + this.relPath + "' src:'" + this.srcRelPath + "']";
  };

  MatchEntry.prototype.toString = function() {
    return this.inspect();
  };

  MatchEntry.prototype.walk = function() {
    if (this.src.isWalkable()) {
      return this.src.node.root.walk(this, this.src.node.target);
    }
  };

  MatchEntry.prototype.isWalkable = function() {
    var _ref;
    return (_ref = this.src).isWalkable.apply(_ref, arguments);
  };

  MatchEntry.prototype.walkPath = function() {
    return this.src.path;
  };

  MatchEntry.prototype.extendVars = function(vars) {
    if (vars == null) {
      vars = {};
    }
    vars.ctx = this.ctx;
    return vars;
  };

  MatchEntry.prototype.newContentTree = function(key) {
    if (key == null) {
      key = this.name0;
    }
    this.contentTree = this.baseTree.newTree(key);
    return this.contentItem = this.contentTree;
  };

  MatchEntry.prototype.newCtxTree = function(key) {
    if (key == null) {
      key = this.name0;
    }
    this.contentTree = this.baseTree.newTree(key);
    return this.contentItem = this.contentTree;
  };

  MatchEntry.prototype.addContentTree = function(key) {
    if (key == null) {
      key = this.name0;
    }
    this.contentTree = this.baseTree.addTree(key);
    return this.contentItem = this.contentTree;
  };

  MatchEntry.prototype.newContent = function(key) {
    if (key == null) {
      key = this.name0;
    }
    return this.contentItem = this.baseTree.newContent(key);
  };

  MatchEntry.prototype.addContent = function(key) {
    if (key == null) {
      key = this.name0;
    }
    return this.contentItem = this.baseTree.addContent(key);
  };

  MatchEntry.prototype.touch = function(arg) {
    if (arg === null) {
      delete this.mtime;
    } else {
      if (arg === true) {
        arg = new Date();
      }
      this.mtime = new Date(Math.max(this.mtime || 0, arg || 0, this.stat.mtime));
    }
    return this.mtime;
  };

  MatchEntry.prototype.fs = require('fs');

  MatchEntry.prototype.readStream = function(options) {
    var src,
      _this = this;
    if (this._overlaySource != null) {
      src = new stream.Stream();
      process.nextTick(function() {
        src.emit('data', _this._overlaySource);
        src.emit('end');
        return src.emit('close');
      });
      return src;
    } else if (this.isFile) {
      return this.fs.createReadStream(this.src.path, options);
    }
  };

  MatchEntry.prototype.read = function(encoding, callback) {
    var _this = this;
    if (encoding == null) {
      encoding = 'utf-8';
    }
    if (typeof encoding === 'function') {
      callback = encoding;
      encoding = 'utf-8';
    }
    if (this._overlaySource != null) {
      process.nextTick(function() {
        return callback(null, _this._overlaySource);
      });
    } else if (this.isFile) {
      this.fs.readFile(this.src.path, encoding, callback);
    }
  };

  MatchEntry.prototype.readSync = function(encoding) {
    if (encoding == null) {
      encoding = 'utf-8';
    }
    if (this._overlaySource != null) {
      return this._overlaySource;
    } else if (this.isFile) {
      return this.fs.readFileSync(this.src.path, encoding);
    }
  };

  MatchEntry.prototype.loadModule = function() {
    if (this._overlaySource != null) {
      throw new Error("`MatchEntry::loadModule()` is not currently support in overlay mode");
    }
    return require(this.src.path);
  };

  MatchEntry.prototype.overlaySource = function(source, callback) {
    var self;
    if (source == null) {
      return this;
    }
    if (source.pipe != null) {
      return this._overlayStream(source, callback);
    }
    self = Object.create(this, {
      overlaysEntry: {
        value: this
      },
      _source: {
        value: source
      }
    });
    process.nextTick(function() {
      return callback(null, self, source);
    });
  };

  MatchEntry.prototype._overlayStream = function(source, callback) {
    var dataList, sendAnswer,
      _this = this;
    dataList = [];
    source.on('data', function(data) {
      return dataList.push(data);
    });
    source.on('error', function(err) {
      return typeof sendAnswer === "function" ? sendAnswer(err) : void 0;
    });
    source.on('end', function() {
      return typeof sendAnswer === "function" ? sendAnswer() : void 0;
    });
    sendAnswer = function(err) {
      sendAnswer = null;
      if (err != null) {
        return callback(err);
      } else {
        return _this.overlaySource(dataList.join(''), callback);
      }
    };
  };

  return MatchEntry;

})();

exports.MatchEntry = MatchEntry;

MatchingWalker = (function(_super) {

  __extends(MatchingWalker, _super);

  function MatchingWalker(site, ruleset) {
    this.site = site;
    this.ruleset = ruleset;
    MatchingWalker.__super__.constructor.call(this, {
      autoWalk: false
    });
    Object.defineProperty(this, '_self_', {
      value: this
    });
  }

  MatchingWalker.prototype.instance = function(baseTree, pluginMap) {
    return Object.create(this._self_, {
      baseTree: {
        value: baseTree
      },
      pluginMap: {
        value: pluginMap || this.pluginMap
      }
    });
  };

  MatchingWalker.prototype.walkListing = function(listing) {
    var entry, tree;
    if ((entry = listing.node.entry) != null) {
      if ((tree = entry.baseTree) == null) {
        tree = entry.addContentTree();
      }
      return this.instance(tree, entry.pluginMap);
    }
    return this;
  };

  MatchingWalker.prototype.walkRootContent = function(aPath, baseTree, pluginMap) {
    return this.instance(baseTree, pluginMap).walk(aPath);
  };

  MatchingWalker.prototype.walkNotify = function() {
    var args, op, _ref;
    op = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return (_ref = this["_op_" + op]) != null ? _ref.apply(this, args) : void 0;
  };

  MatchingWalker.prototype._op_dir = function(entry) {
    entry = new MatchEntry(entry, this.baseTree, this.pluginMap);
    return this.ruleset.matchRules(entry, this);
  };

  MatchingWalker.prototype._op_file = function(entry) {
    entry = new MatchEntry(entry, this.baseTree, this.pluginMap);
    return this.ruleset.matchRules(entry, this);
  };

  MatchingWalker.prototype.match = function(entry, matchKind) {
    var matchMethod, plugin;
    matchMethod = entry.setMatchMethod(matchKind);
    plugin = this.pluginMap.findPlugin(entry);
    return this.site.matchEntryPlugin(plugin, entry, matchMethod);
  };

  return MatchingWalker;

})(tromp.WalkRoot);

exports.MatchingWalker = MatchingWalker;

exports.createWalker = function(site, ruleset) {
  return new MatchingWalker(site, ruleset);
};
